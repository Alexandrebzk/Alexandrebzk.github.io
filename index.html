
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>TUTORIEL APPLICATION NATIVE JAVA</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="Alexandrebzk.github.io"
                  title="TUTORIEL APPLICATION NATIVE JAVA"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Introduction" duration="5">
        <p>Bienvenue dans ce petit tutoriel sur les applications natives JAVA. J&#39;ai essayé d&#39;être le plus exhaustif possible. Vous allez créer aujourd&#39;hui une superbe application android qui représente un système de connexion. Nous aborderons différents points tout au long de cette merveilleuse expérience. Pour vous donner un peu envie d&#39;aller jusqu&#39;au bout, voici à quoi ressemblera l&#39;application terminée:</p>
<p class="image-container"><img style="width: 250.00px" src="img/a2f3877254bac6fe.gif"></p>
<p>Par soucis de bienveillance de ma part, vous avez accès à un repository que voici : <a href="https://github.com/Alexandrebzk/Tutoriel-JAVA" target="_blank">Tutoriel JAVA</a>. Il vous sera propos tout au long du tutoriel, au cas ou, de repartir d&#39;une base pour démarrer l&#39;étape suivante. Ces étapes seront identifiées par des TAGS.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Installation Android Studio" duration="30">
        <p>Vous pouvez télécharger Android Studio 4.2.1 depuis <a href="https://developer.android.com/studio/" target="_blank">cette page</a>.</p>
<p>Si vous ne disposez d&#39;aucun JDK, ce n&#39;est pas grave, tout vient avec le téléchargement d&#39;Android Studio.</p>
<p>Voici les quelques étapes que vous serez menés à réaliser:</p>
<ul>
<li>Accédez à la page de téléchargement d&#39;Android Studio et suivez les instructions pour télécharger et installer Android Studio.</li>
<li>Acceptez les configurations par défaut pour toutes les étapes et assurez-vous que tous les composants sont sélectionnés pour l&#39;installation.</li>
<li>Une fois l&#39;installation terminée, l&#39;assistant de configuration télécharge et installe des composants supplémentaires, y compris le SDK Android. Soyez patient, car ce processus peut prendre un certain temps, selon la vitesse de votre connexion Internet.</li>
<li>Enfin, Android Studio démarre et vous êtes prêt à créer votre premier projet.</li>
</ul>
<aside class="warning"><p><strong>Dépannage</strong>: si vous rencontrez des problèmes avec votre installation, consultez <a href="https://developer.android.com/studio/releases" target="_blank">les notes de version</a> d&#39;Android Studio ou <a href="https://developer.android.com/studio/troubleshoot" target="_blank">la section de résolution de problème</a> d&#39;Android Studio.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Création du projet" duration="20">
        <p>Dans cette étape, vous allez créer un nouveau projet Android pour votre première application. Cette application simple affiche la chaîne &#34;Hello World&#34; sur l&#39;écran d&#39;un appareil virtuel ou physique Android. Pour éviter des potentiels problèmes, nous utiliserons dans ce tutoriel l&#39;appareil émulé par Android Studio.</p>
<h2 is-upgraded><strong>Ce que vous apprendrez</strong></h2>
<ul>
<li>Comment créer un projet dans Android Studio.</li>
<li>Comment créer un appareil Androaid émulé.</li>
<li>Comment exécuter votre application sur l&#39;émulateur.</li>
</ul>
<h2 is-upgraded><strong>Étape 1: Créer un nouveau projet</strong></h2>
<ol type="1">
<li>Ouvrir Android Studio</li>
<li>Dans la boîte de dialogue Bienvenue dans Android Studio, cliquez sur Démarrer un nouveau projet Android Studio.</li>
<li>Sélectionnez Activité de base (pas la valeur par défaut). Cliquez sur Suivant.<img style="width: 600.00px" src="img/cec9de7699524c2c.png"></li>
<li>Donnez à votre application un nom tel que <strong>Ma première application avec Alexandre qui va être superbe</strong><img style="width: 600.00px" src="img/fd193ddc19cfe43c.png"></li>
<li>Assurez-vous que le <strong>langage</strong> est défini sur **Java ** (et pas Kotlin).</li>
<li>Laissez les valeurs par défaut pour les autres champs.</li>
<li>Cliquez sur <strong>Terminer</strong>.</li>
</ol>
<p>Après ces étapes, Android Studio :</p>
<ul>
<li>Crée un dossier pour votre projet Android Studio appelé <strong>Ma première application avec Alexandre qui va être superbe</strong>. C&#39;est généralement dans un dossier appelé <strong>AndroidStudioProjects</strong> sous votre répertoire personnel (cmd+shift+H sur mac).</li>
<li>Construit votre projet (cela peut prendre quelques instants). Android Studio utilise <a href="https://gradle.org/" target="_blank">Gradle </a>comme système de construction. Vous pouvez suivre la progression de la construction en bas de la fenêtre Android Studio.</li>
<li>Ouvre l&#39;éditeur de code affichant votre projet.</li>
</ul>
<h2 is-upgraded><strong>Étape 2: Créer un périphérique virtuel (émulateur)</strong></h2>
<p>Dans cette tâche, vous allez utiliser le <a href="http://developer.android.com/tools/devices/managing-avds.html" target="_blank">gestionnaire d&#39;appareils virtuels Android (AVD) </a>pour créer un appareil virtuel (ou émulateur) qui simule la configuration d&#39;un type particulier d&#39;appareil Android.</p>
<p>La première étape consiste à créer une configuration qui décrit le périphérique virtuel.</p>
<ol type="1">
<li>Dans Android Studio, sélectionnez <strong>Outils</strong> &gt; <strong>Gestionnaire AVD</strong>, ou cliquez sur l&#39;icône Gestionnaire AVD dans la barre d&#39;outils.</li>
<li>Cliquez sur <strong>+Créer un périphérique virtuel</strong>. (Si vous avez déjà créé un périphérique virtuel, la fenêtre affiche tous vos appareils existants et le bouton <strong>+Créer un périphérique virtuel</strong> se trouve en bas.). La fenêtre <strong>Sélectionner du matériel</strong> affiche une liste de définitions de périphériques matériels préconfigurées.</li>
<li>Choisissez une définition d&#39;appareil, telle que <strong>Pixel 3a</strong>, puis cliquez sur <strong>Suivant</strong>. (Pour ce tutoriel, peu importe la définition de périphérique que vous choisissez).</li>
<li>Dans la boîte de dialogue <strong>Image système</strong>, dans l&#39;onglet <strong>Recommandé</strong>, choisissez la dernière version. (Cela importe.)</li>
<li>Si un lien <strong>de téléchargement</strong> est visible à côté d&#39;une dernière version, il n&#39;est pas encore installé et vous devez d&#39;abord le télécharger. Si nécessaire, cliquez sur le lien pour démarrer le téléchargement, puis cliquez sur <strong>Suivant</strong> lorsque c&#39;est terminé. Cela peut prendre un certain temps en fonction de la vitesse de votre connexion.</li>
</ol>
<aside class="special"><p><strong>Remarque :</strong> Les images système peuvent prendre une grande quantité d&#39;espace disque, ne téléchargez que ce dont vous avez besoin.</p>
</aside>
<h2 is-upgraded><strong>Étape 3 : Exécutez votre application sur votre nouvel émulateur</strong></h2>
<ol type="1">
<li>Dans Android Studio, sélectionnez <strong>Exécuter &gt; Exécuter « application »</strong> (^R sur mac) ou cliquez sur l&#39;icône <strong>Exécuter</strong> dans la barre d&#39;outils <img style="width: 30.00px" src="img/11d7412697cbd908.png">. L&#39;icône changera lorsque votre application sera déjà en cours d&#39;exécution <img style="width: 30.00px" src="img/5a682ac015c68de8.png">.</li>
</ol>
<p>Si vous obtenez une boîte de dialogue indiquant &#34;L&#39;exécution instantanée nécessite que la plate-forme correspondant à votre appareil cible (Android N...) soit installée&#34;, allez-y et cliquez sur <strong>Installer et continuez.</strong></p>
<ol type="1">
<li>Dans <strong>Exécuter &gt; Sélectionner un appareil</strong>, sous <strong>Appareils disponibles</strong>, sélectionnez le périphérique virtuel que vous venez de configurer. Ce menu apparaît également dans la barre d&#39;outils.</li>
</ol>
<p class="image-container"><img style="width: 250.00px" src="img/ae02611248db1edc.png"></p>
<p>L&#39;émulateur démarre et démarre comme un appareil physique. Selon la vitesse de votre ordinateur, cela peut prendre un certain temps. Vous pouvez regarder dans la petite barre d&#39;état horizontale tout en bas d&#39;Android Studio les messages pour voir la progression.</p>
<p class="image-container"><img style="width: 250.00px" src="img/85293744fdf6341d.png"></p>
<p>Une fois que votre application est construite et que l&#39;émulateur est prêt, Android Studio télécharge l&#39;application sur l&#39;émulateur et l&#39;exécute. Vous devriez voir votre application comme indiqué dans la capture d&#39;écran suivante.</p>
<aside class="special"><p><strong>Remarque</strong> : C&#39;est une bonne pratique de démarrer l&#39;émulateur au début de votre session. Ne fermez pas l&#39;émulateur avant d&#39;avoir terminé de tester votre application, de sorte que vous n&#39;ayez pas à attendre que l&#39;émulateur redémarre. En clair, n&#39;ayez pas plus d&#39;un émulateur en cours d&#39;exécution à la fois, pour réduire l&#39;utilisation de la mémoire.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Exploration de l&#39;IDE" duration="15">
        <p>En règle générale, chaque écran de votre application Android est associé à un ou plusieurs fragments. L&#39;écran unique affichant &#34;Hello first fragment&#34; est créé par un fragment, appelé FirstFragment.</p>
<p>Cela a été généré pour vous lorsque vous avez créé votre nouveau projet. Chaque fragment visible dans une application Android a une disposition qui définit l&#39;interface utilisateur du fragment. Android Studio dispose d&#39;un éditeur de mise en page dans lequel vous pouvez créer et définir des mises en page.</p>
<p>Les mises en page sont définies en <a href="https://en.wikipedia.org/wiki/XML" target="_blank">XML</a>. L&#39;éditeur de mise en page vous permet de définir et de modifier votre mise en page soit en codant en XML, soit en utilisant l&#39;éditeur visuel interactif.</p>
<p>Chaque élément d&#39;une mise en page est une vue. Dans cette section, vous explorerez certains des panneaux de l&#39;éditeur de mise en page et vous apprendrez à modifier la propriété des vues.</p>
<h2 is-upgraded><strong>Ce que vous apprendrez</strong></h2>
<ul>
<li>Comment utiliser l&#39;éditeur de mise en page.</li>
<li>Comment définir les valeurs des propriétés.</li>
<li>Comment ajouter/modifier des ressources.</li>
</ul>
<h2 is-upgraded><strong>Étape 1 : Ouvrez l&#39;éditeur de mise en page</strong></h2>
<ol type="1">
<li>Trouvez et ouvrez le dossier de <strong>mise en page</strong> (<strong>app &gt; res &gt; layout</strong>) sur le côté gauche dans le panneau <strong>Projet</strong>.</li>
</ol>
<aside class="warning"><p><strong>Dépannage :</strong> Si vous ne voyez pas le fichier <code>fragment_first.xml</code>, vérifiez que vous utilisez Android Studio 3.6 (ou supérieur, mais si vous avez suivi la partie installation ça devrait être bon).</p>
</aside>
<p>Les panneaux à droite de la vue Projet comprennent l&#39;éditeur de <em>mise en page</em>. Ils peuvent être disposés différemment dans votre version d&#39;Android Studio, mais la fonction est la même.</p>
<p class="image-container"><img style="width: 600.00px" src="img/17b99ea3655bd789.png"></p>
<p>Sur la gauche se trouve une <strong>palette (1)</strong> de vues que vous pouvez ajouter à votre application.</p>
<p>Juste en dessous se trouve une <strong>arborescence de composants (2)</strong> montrant les vues actuellement dans ce fichier et la façon dont elles sont organisées les unes par rapport aux autres.</p>
<p>Au centre se trouve <strong>l&#39;éditeur de conception (3)</strong>, qui affiche une représentation visuelle de ce à quoi ressemblera le contenu du fichier lorsqu&#39;il sera compilé. Vous pouvez afficher la représentation visuelle, le code XML, ou les deux.</p>
<p>Enfin, sur la droite se trouve la <strong>palette d&#39;attributs (4)</strong>. Cette partie recense toutes les propriétés de l&#39;élément que vous sélectionnez dans l&#39;éditeur de conception.</p>
<h2 is-upgraded><strong>Étape 2: Définition des propriétés</strong></h2>
<p>Vous l&#39;aurez surement déjà remarqué si vous êtes un peu curieux mais on peut voir ce qu&#39;il se passe derrière cet éditeur de conception. Comme dit plus haut, c&#39;est codé en XML. Vous disposez de 3 boutons très utiles que voici :</p>
<p class="image-container"><img style="width: 250.00px" src="img/fe473d91047dfacb.png"></p>
<p>La vue qui est déjà sélectionnée (<strong>Design</strong>) est celle que je vous ai présenté dans la partie précédente. La vue <strong>Code</strong> vous permet d&#39;accéder au code XML et la vue <strong>Split</strong> vous montre les deux.</p>
<p>On va se concentrer sur la vue Code pour expliquer la définition des propriétés:</p>
<p class="image-container"><img style="width: 600.00px" src="img/29e274fd980fbd00.png"></p>
<p>Ici on retrouve l&#39;arborescence des composants (ConstraintLayout &gt; (TextView + Button)). Ce qui nous interresse surtout dans cette partie c&#39;est comment modifier par exemple ce que contient le bouton &#34;Next&#34; de la page d&#39;accueil.</p>
<h2 is-upgraded><strong>Étape 3: Ajout/modification des propriétés</strong></h2>
<p>On peut voir ci-dessus le champ <code>android:text=&#34;Next&#34;</code> mais ce &#34;Next&#34; est grisé. En fait, c&#39;est Android Studio qui vous montre la valeur de la propriété mais quand on clique dessus on découvre que c&#39;est une adresse vers un autre champ: <code>android:text=&#34;@string/next&#34;</code>. En faisant un Ctrl + clic (cmd + clic sur mac), on peut accéder à cette adresse et y trouve toutes les variables utilisables en tant que champ &#34;texte&#34;.</p>
<p class="image-container"><img style="width: 600.00px" src="img/ff2d56fb9258a455.png"></p>
<p>Pour changer la valeur du boutton il nous suffit donc de changer ce champ : <code>&lt;string name=&#34;next&#34;&gt;Nouveau Next&lt;/string&gt;</code>. On peut également accéder à ce champ d&#39;une deuxieme manière (elle est plus élégante). En passant par le panel des attributs:</p>
<p class="image-container"><img style="width: 600.00px" src="img/764362521bb4b578.png"></p>
<aside class="warning"><p><strong>Dépannage</strong>: Si rien ne s&#39;affiche dans le panel d&#39;attributs, faites bien attention à sélectionner le composant qui vous interesse (ici, le bouton NEXT).</p>
</aside>
<aside class="special"><p><strong>Astuce</strong>: Pour trouver facilement une propriété, vous pouvez la chercher en tapant son nom dans la petite loupe en haut du panel.</p>
</aside>
<p>Il existe plusieurs fichiers de ce type qui servent à définir d&#39;autres propriétés, ils sont tous dans le dossier <strong>res &gt; values</strong> :</p>
<p class="image-container"><img style="width: 250.00px" src="img/365242299f3a5518.png"></p>
<p>Ces fichiers servent à renseigner comme vous l&#39;aurez compris des dimensions, des couleurs ou des champs texte.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Ajout des composants" duration="30">
        <p>Voici l&#39;objectif de cette partie :</p>
<p class="image-container"><img style="width: 250.00px" src="img/daf9b90a91ec4066.png"></p>
<h2 is-upgraded><strong>Ce que vous apprendrez</strong></h2>
<ul>
<li>Comment ajouter de nouvelles vues à votre mise en page.</li>
</ul>
<h2 is-upgraded><strong>Ajouter de nouvelles vues à notre page</strong></h2>
<p>Nous allons dans cette partie mettre en place les champs nécessaires à la connexion utilisateur. Énumérons tout d&#39;abord les champs que nous allons devoir ajouter:</p>
<ul>
<li>Un champ texte pour le nom utilisateur/email</li>
<li>Un champ password pour le mot de passe</li>
<li>Changer le bouton Next en bouton Sign In (normalement ça vous savez déjà faire !)</li>
<li>Un lien vers un autre composant pour l&#39;inscription et un autre pour la récupération de mot de passe.</li>
<li>Un magnifique logo pour rendre tout ça un peu plus agréable</li>
</ul>
<p>Pour bien comprendre l&#39;architecture à laquelle nous avons à faire, voici un petit schéma:</p>
<p class="image-container"><img style="width: 250.00px" src="img/293d8e3df004af6e.png"></p>
<p><strong>Activity_main</strong> : Représente l&#39;application, contient la toolbar (la bande bleue) et le contenu de l&#39;application</p>
<p><strong>Content_main</strong> : Contenu le l&#39;application, contient des fragments</p>
<p><strong>First/Second_fragment</strong> : Ce sont les vues que nous allons utiliser. Ces fragments peuvent s&#39;apparenter à des widgets.</p>
<p>On peut également imaginer cette architecture assez facilement dans la partie arborescence des composants :</p>
<p>​			<code>activity_main.xml</code> ==&gt; <code>content_main.xml</code></p>
<p><img style="width: 250.00px" src="img/d22ef5e0c6e312f2.png">=== <img style="width: 250.00px" src="img/eff9ce7899da8567.png"></p>
<p>On voit lorsque l&#39;on double clic sur l&#39;include dans <code>activity_main.xml</code> qu&#39;on arrive dans <code>content_main.xml</code> qui lui contient un composant appelé <code>nav_host_fragment</code>, qui lui même héberge les fragments.</p>
<aside class="warning"><p><strong>Question</strong>: Quel vue va-t-on modifier pour y ajouter les champs que l&#39;on a précédemment identifiés ?</p>
</aside>
<p>Ça ne marche pas vraiment si la réponse est écrite juste en dessous... Mais j&#39;ose espérer que vous avez essayé de répondre sans regarder . On doit donc modifier le fichier <code>fragment_first.xml</code> et y ajouter les champs que l&#39;on a identifié !</p>
<p>Maintenant c&#39;est à vous de jouer ! Je vous laisse trifouiller cette merveilleuse palette de composants pour coller au maximum à l&#39;objectif !</p>
<aside class="special"><p><strong>Aide</strong>: Si vous n&#39;arrivez pas à trouver les types de composant à utiliser, voici les réponses :   </p>
<ul>
<li>Username --&gt; Text &gt; Email</li>
<li>Mot de passe --&gt; Text &gt; Password</li>
<li>Logo --&gt; Widgets &gt; ImageView</li>
<li>Liens --&gt; Text &gt; TextView</li>
</ul>
</aside>
<p>Si vous avez l&#39;âme d&#39;un graphiste en vous, ce que vous venez de créer ressemble à peu près à l&#39;original !</p>
<p>Vous avez peut être également remarqué la présence de ronds sur les 4 coins d&#39;un composant lorsque vous le sélectionnez. Par convention, un composant ne peut pas être &#34;flottant&#34;, il faut toujours qu&#39;il soit relié à quelque chose.</p>
<p class="image-container"><img style="width: 250.00px" src="img/72ef5a287e08a415.png"></p>
<p>Ici, on décide de centrer tous les composants, donc on les relie à gauche et à droite aux bords du fragment. Concernant le rond du haut, j&#39;ai pour habitude de relier à son composant du dessus et pour le bas, la limite du bas du fragment.</p>
<aside class="warning"><p><strong>Roue de secours</strong>: Si vous n&#39;avez pas réussi cette partie, placez vous sur le tag &#34;<strong>HomePage</strong>&#34;. <code>git checkout tags/HomePage</code></p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Récupération des inputs" duration="10">
        <h2 is-upgraded><strong>Ce que vous apprendrez</strong></h2>
<ul>
<li>Identifier de manière claire un composant dans une vue</li>
<li>Récupérer et extraire sa valeur</li>
</ul>
<h2 is-upgraded><strong>Identification claire d&#39;un composant</strong></h2>
<p>Il est primordial de garder une cohérence de nommage pour les composants, ou de manière générale d&#39;ailleurs. Deux conventions sont très répandues:</p>
<ul>
<li>le snake case : <code>composant_id</code></li>
<li>le camel case : <code>composantId</code></li>
</ul>
<p>Vous pouvez choisir celle que vous voulez (mais je vous conseille quand même le camel case car on écrit plus vite), le plus important et d&#39;appliquer la même convention partout. J&#39;ai choisi pour ma part le camel case.</p>
<h2 is-upgraded><strong>Récupérer et extraire les données des composants</strong></h2>
<p>Chaque composant d&#39;une vue est caractérisé par un identifiant unique. Ces identifiants sont ensuite chargés dans un contexte accessible depuis la partie JAVA qui est représenté par la variable globale R. Cette variable, qui ne nécessite pas d&#39;import, est la librairie qui contient tous les identifiants, tous les layouts, plus généralement toutes les Ressources de l&#39;application.</p>
<p>Pour accéder à un certain composant, on va donc procéder de la sorte :</p>
<pre><code language="language-java" class="language-java">final EditText usernameEditText = view.findViewById(R.id.idUsername);
</code></pre>
<aside class="warning"><p><strong>​Remarque</strong>: Ici on vient assigner à notre variable usernameEditText le composant qui représente le username et non pas seulement sa valeur !</p>
</aside>
<p>Avant de se ruer sur le code, tentons tout d&#39;abord d&#39;expliquer comment un fragment se comporte avec son contenu.</p>
<p class="image-container"><img style="width: 600.00px" src="img/da4f0c74977888ce.png"></p>
<p>À la manière du JavaScript, le fragment va placer des &#34;Listener&#34; sur un ou plusieurs de ses composants pour effectuer des actions suivant certaines conditions. Ici on peut constater que le bouton SignIn, retrouvé par son identifiant, va se voir attribuer un Listener qui se déclenchera dès que celui-ci fera l&#39;objet d&#39;un clic. Comme vous pouvez le voir, on peut ajouter autant de listener qu&#39;on peut effectuer d&#39;actions avec le composant, il suffit d&#39;override les méthodes possibles.</p>
<p>Maintenant qu&#39;on voit à peu près comment ça marche, on peut récupérer les champs username et password et les afficher dans notre console pour vérifier que cela fonctionne comme prévu:</p>
<pre><code language="language-java" class="language-java">        final EditText usernameEditText = view.findViewById(R.id.idUsername);
        final EditText passwordEditText = view.findViewById(R.id.idPassword);
        final Button loginButton = view.findViewById(R.id.idSignIn);

        loginButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Log.i(&#34;FRAGMENT 1, username :&#34;,usernameEditText.getText().toString());
                Log.i(&#34;FRAGMENT 1, password :&#34;,passwordEditText.getText().toString());
                // NavHostFragment.findNavController(FirstFragment.this).navigate(R.id.action_FirstFragment_to_SecondFragment);
            }
        });
</code></pre>
<aside class="special"><p><strong>Remarque</strong>: L&#39;usage du Logger est à consommer sans modération !   Il est très puissant et est accessible très facilement depuis la partie &#34;run&#34; de Android studio:   <img src="img/99e54c7d72a476a7.png">  </p>
</aside>
<aside class="warning"><p><strong>Roue de secours</strong>: Si vous n&#39;avez pas réussi cette partie, placez vous sur le tag &#34;<strong>RetrieveInputs</strong>&#34;. <code>git checkout tags/RetrieveInputs</code></p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Discussion avec une API" duration="30">
        <h2 is-upgraded><strong>Ce que vous apprendrez dans cette partie</strong></h2>
<ul>
<li>Introduction à Retrofit2</li>
<li>Contacter et traiter une réponse API</li>
</ul>
<p>Dans cette partie on va voir comment contacter une API depuis une application android. Il existe diverses solutions mais pour vous éviter de trop longues recherches, et surtout parce que c&#39;est mon travail de vous fournir les outils, nous allons utiliser Retrofit2.</p>
<h2 is-upgraded><strong>Introduction à Retrofit2</strong></h2>
<p>Retrofit2 est un package qui rassemble toutes les méthodes pour pouvoir contacter une API. Il nécessite cependant de créer une sorte d&#39;entité JAVA pour stocker la réponse de l&#39;API.</p>
<p>On va donc commencer par créer cette entité :</p>
<pre><code language="language-java" class="language-java">public class SessionToken {

    private String token;
    private LocalDateTime expirationDate;
  //...
}
</code></pre>
<p>Voici ce que l&#39;API nous répond:</p>
<ul>
<li>Un token, qui nous servira par la suite de passe-droit lors d&#39;appels API sécurisés</li>
<li>Une date d&#39;expiration, car s&#39;il n&#39;y en avait pas... Ce serait la débandade !</li>
</ul>
<p>Maintenant que nous avons la réponse API sous forme d&#39;entité, nous allons maintenant définir l&#39;appel que nous voulons faire :</p>
<pre><code language="language-java" class="language-java">public interface AuthAPI {

    @GET(&#34;ping&#34;)
    Call&lt;String&gt; ping();

    @POST(&#34;v1/authentication/login&#34;)
    @Headers(&#34;Content-type: application/json&#34;)
    Call&lt;SessionToken&gt; loginUser(@Body JsonObject authInput);
	
  	//...
}
</code></pre>
<p>On définit dans cette classe les méthodes que l&#39;on va potentiellement utiliser:</p>
<ul>
<li>ping(): je pense que le nom parle de lui même, cependant, le protocole de communication est précisé avec une directive @GET qui pointera sur l&#39;url &#34;ping&#34;.</li>
<li>loginUser:  <ul>
<li>On précise tout d&#39;abord que l&#39;on utilise le protocole POST sur la route <code>&#34;v1/authentication/login&#34;</code></li>
<li>On averti l&#39;API que nous discutons en format JSON en ajoutant <code>&#34;Content-type: application/json&#34;</code> aux HEADERS de la future requête</li>
<li>On précise que ce que l&#39;on envoi est un objet JSON</li>
<li>On récupèrera un objet Call de SessionToken. Cet Objet nous permettra par la suite de traiter la requête de plusieurs manières. Vous comprendrez par la suite promis.</li>
</ul>
</li>
</ul>
<p>Si vous avez bien fait vos devoirs en cours, vous devriez avoir cette arborescence:</p>
<p class="image-container"><img style="width: 250.00px" src="img/d945f8b051f68a43.png"></p>
<p>On sait ce que l&#39;on manipule et comment on va discuter avec l&#39;API, je pense qu&#39;on est prêt à passer quelques appels.</p>
<h2 is-upgraded><strong>Contacter et traiter une réponse API</strong></h2>
<p>Avant de commencer à coder l&#39;appel API, il faut préciser dans le manifeste de notre application qu&#39;elle peut converser avec l&#39;extérieur:</p>
<pre><code language="language-xml" class="language-xml">&lt;manifest xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;
    package=&#34;com.example.mapremireapplicationavecalexandrequivatresuperbe&#34;&gt;

	&lt;!-- ... --&gt;
  &lt;uses-permission android:name=&#34;android.permission.INTERNET&#34; /&gt;
  
  &lt;application
    //...
  	android:usesCleartextTraffic=&#34;true&#34;
    //...
  &gt;
	&lt;!-- ... --&gt;
  &lt;/application&gt;
&lt;/manifest&gt;
</code></pre>
<p>Maintenant que notre application a accès à internet, il nous faut importer cette fameuse librairie Retrofit2. Pour cela, on va l&#39;ajouter à notre gestionnaire de dépendences <strong>Gradle</strong> :</p>
<p><code>app/build.gradle</code></p>
<pre><code language="language-json" class="language-json">dependencies {
  //...
    implementation &#39;com.squareup.retrofit2:retrofit:2.4.0&#39;
    implementation &#39;com.squareup.retrofit2:converter-gson:2.4.0&#39;
    implementation &#39;com.squareup.retrofit2:adapter-rxjava:2.4.0&#39;
  //...
}
</code></pre>
<p>De retour dans notre fragment 1, on va maintenant faire plus que logger les identifiants !</p>
<p>On doit d&#39;abord instancier un Mapper. Comme son nom l&#39;indique, il sert à transformer (ou &#34;mapper&#34;) les objets JAVA en objet JSON et inversement.</p>
<pre><code language="language-java" class="language-java">Gson gson = new GsonBuilder()
  .registerTypeAdapter(LocalDateTime.class, (JsonDeserializer&lt;LocalDateTime&gt;) (json, typeOfT, context) -&gt; LocalDateTime.parse(json.getAsString()))
  .setLenient()
  .create();
</code></pre>
<aside class="special"><p><strong>Astuce</strong>: On peut attacher des comportements particuliers à notre mapper, ici on assigne un parser spécial pour être sûr de bien interpreter la réponse serveur.</p>
</aside>
<p>Ensuite on déclare notre fameux objet Retrofit. On y attache notre mapper pour être sûr de traiter les champs de la bonne manière.</p>
<pre><code language="language-java" class="language-java">Retrofit retrofit = new Retrofit.Builder()
  .baseUrl(&#34;http://dourlens-monchy.fr:8090/&#34;)
  .addConverterFactory(GsonConverterFactory.create(gson))
  .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
  .build();
</code></pre>
<p>Nous sommes heureux de pouvoir utiliser ce merveilleux objet qui va nous permettre de discuter avec notre serveur. Il nous faut maintenant instancier la classe recensant les méthodes que nous avons décrites précédemment:</p>
<pre><code language="language-java" class="language-java">AuthAPI authAPI = retrofit.create(AuthAPI.class);
Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();
params.put(&#34;username&#34;, usernameEditText.getText().toString());
params.put(&#34;password&#34;, passwordEditText.getText().toString());
Call&lt;SessionToken&gt; apiCall = authAPI.loginUser(JsonUtils.mapToJSON(params));
</code></pre>
<p>Par soucis de généralisation je vous propose cette classe <code>JsonUtils</code> qui vous permet de transformer un type <code>Map&lt;String,Object&gt;</code> en objet JSON. Cela permet dans le cas présent de créer le body de notre requête de login.</p>
<pre><code language="language-java" class="language-java">public class JsonUtils {

  public static JsonObject mapToJSON(Map&lt;String, Object&gt; params) {

    JsonObject gsonObject = new JsonObject();
    try {
      JSONObject jsonObj_ = new JSONObject();
      for (Map.Entry&lt;String, Object&gt; entry : params.entrySet()) {
        jsonObj_.put(entry.getKey(), entry.getValue());
      }
      JsonParser jsonParser = new JsonParser();
      gsonObject = (JsonObject) jsonParser.parse(jsonObj_.toString());

      //print parameter
      Log.d(&#34;MY gson.JSON:  &#34;, &#34;AS PARAMETER  &#34; + gsonObject);

    } catch (JSONException e) {
      e.printStackTrace();
    }

    return gsonObject;
  }


}
</code></pre>
<p>Nous sommes désormais en possession d&#39;un objet qui contient notre requête, elle n&#39;est cependant toujours pas lancée. Pour cela, il faut lancer la fonction <code>enqueue</code>.</p>
<pre><code language="language-java" class="language-java">apiCall.enqueue(new Callback&lt;SessionToken&gt;() {
  @Override
  public void onResponse(Call&lt;SessionToken&gt; call, Response&lt;SessionToken&gt; response) {
    assert response.body() != null;
    SessionToken sessionToken = new SessionToken(response.body());
    Log.i(&#34;Session Token&#34;,sessionToken.toString());
  }

  @Override
  public void onFailure(Call&lt;SessionToken&gt; call, Throwable t) {
    Log.i(&#34;ERROR&#34;,t.getMessage());
  }
});
</code></pre>
<p>Cette fonction nous permet d&#39;interprêter la réponse serveur, peut importe sa nature. Dans un cas de succès, la fonction <code>onResponse</code> sera exécutée, dans la cas contraire <code>onFailure</code>.</p>
<p>La magie apparait lorsque l&#39;on lance l&#39;application et que l&#39;on voit notre token apparaitre !</p>
<p class="image-container"><img style="width: 600.00px" src="img/f116ce53d27bb017.png"></p>
<aside class="warning"><p><strong>Roue de secours</strong>: Si vous n&#39;avez pas réussi cette partie, placez vous sur le tag &#34;<strong>APICall</strong>&#34;. <code>git checkout tags/APICall</code></p>
</aside>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
